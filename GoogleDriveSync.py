#!/usr/bin/env python
#TODO: update witn method and class summaries
u"""GoogleDriveSync Module - Sync a folder with Google Drive

This Module aims to provide a completely cross platform way to sync a 
directory with Google Drive and tries to provide some advanced options not
found on current projects that perform simmilar tasks

TODO: Add summaries of included classes and methods

FMI - visit our project page at github:
    https://github.com/AccaliaDeElementia/GoogleDriveSync
Or visit our wiki at:
    https://github.com/AccaliaDeElementia/GoogleDriveSync/wiki

(C)2013 by Accalia de Elementia [accalia.de.elementia (at) gmail.com]
This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 
Unported License. To view a copy of this license, visit 
    http://creativecommons.org/licenses/by-sa/3.0/.

This module has super Fluttershy powers.
"""
import os
import re
import cPickle as pickle

from pprint import pprint
from datetime import datetime
from fnmatch import fnmatch
from os import path
from sys import argv
from ConfigParser import SafeConfigParser as ConfigParser

#Mimetype guessing
from magic import Magic

#Httplib2 imports
from httplib2 import Http

# Google Api Client imports
from apiclient import errors
from apiclient.discovery import build
from apiclient.http import MediaFileUpload
from oauth2client.client import OAuth2WebServerFlow

MIME = Magic(mime=True)

class GoogleDriveSyncError(Exception):
    u"""Base exception used by GoogleDriveSync.

    Any exception generated by GoogleDriveSync will be an instance of this 
    class, or of a subclass.
    """
    pass

class Config (object):
    u"""Handle configuration options for GoogleDriveSync

    These include paths to items such as stored OAuth2 credentials.
    """
    #TODO: This should probably be implemented as a singleton or static class.
    DIR = u'.GoogleDriveSync'
    CONFIG = DIR + os.sep + u'GoogleDriveSync.cfg'
    CREDENTIALS = DIR + os.sep + u'credentials.pkl'
    IGNORE = DIR + os.sep + 'syncignore'
    CACHE = DIR + os.sep + u'GoogleDriveSync.cache'
    DLFIELDS = ('nextPageToken,items(id,title,mimeType,downloadUrl,' + 
             'fileSize,modifiedDate,parents(id),labels,md5Checksum)')
    ULFIELDS = ('id,title,mimeType,downloadUrl,' + 
             'fileSize,modifiedDate,parents(id),labels,md5Checksum')

    def __init__(self):
        u"""Initialize the configuration parser.

        NOTE: This will not automatically load configuration. that will be 
        done automatically by a call to any of the public methods. maybe
        this shouldn't be the case?
        """
        #DOCTODO See note in above docstring
        self.__cfg = ConfigParser()
        self.__loaded = False

    def __load(self):
        u"""Load configuration if not already loaded.
        """
        if self.__loaded: 
            return
        try:
            if not path.exists(self.DIR):
                os.mkdir(self.DIR)
            with open(self.CONFIG, 'r') as conf:
                self.__cfg.readfp(conf)
            self.__loaded = True
        except:
            pass

    def get (self, section, option, parser=unicode, error=False):
        u"""Get configuration option as parsed by provided parser.

        Keyword arguments:
        section -- The confiuration section to search in.
        option -- The name of the configuration option to get
        parser -- Conversion function for option (default: unicode)
        error -- If True raise exception on error, otherwise return None
                    (default: False)
        """
        self.__load()
        if not self.__cfg.has_section(section):
            if error:
                raise GoogleDriveSyncError('Section not exist')
            else:
                return None
        if self.__cfg.has_option(section, option):
            return parser(self.__cfg.get(section, option))
        elif error:
            raise GoogleDriveSyncError('Option not exist')
        return None

    def set(self, section, option, value, persist=False):
        u"""Set provided configuration option.

        Will add configuration section to configuration if needed.

        Keyword arguments:
        section -- Section name to set value to
        option -- Option name to set value of
        value -- value to set
        persist -- If True update configuration on disk (default: False)
        """
        self.__load()
        if not self.__cfg.has_section(section):
            self.__cfg.add_section(section)
        self.__cfg.set(section, option, value)
        if persist:
            with open(self.CONFIG, 'w') as conf:
                self.__cfg.write(conf)

    def ignore_list(self):
        u"""Read and return list of ignore patterns.
        """
        ignore = [self.DIR+u'/']
        if path.exists(self.IGNORE):
            with open(self.IGNORE, 'r') as igfile:
                for line in igfile:
                    line = unicode(line.strip())
                    if len(line) and line[0] != u'#':
                        ignore.append(line)
        return ignore
CONFIG = Config()


class Auth (object):
    #TODO: update with method summaries
    u"""Handle Authorization with Google.
    """
    def __init__(self):
        u"""Initialize Auth object and create Http instance to authorize
        """
        self.http = Http()
        self.credentials = None

    def create_authorization(self, overwrite=False):
        u"""Perform OAuth2 authorization with Google.

        Store credentials for use in later runs. Specify overwrite to force
        overwrite of previously stored credentials.

        Keyword arguments:
        overwrite -- If True force overwrite of previously stored credentials.
        """
        #TODO: Implement creation of stored credentials
        raise NotImplementedError('TODO')

    def authorize (self):
        u"""Authorize Http instance with stored credentials.
        
        Requires previously stored credentials to be valid.
        """
        if not path.exists(CONFIG.CREDENTIALS):
            raise GoogleDriveSyncError(
                'No stored credentials found. Must authorize first')
        with open(CONFIG.CREDENTIALS, 'rb') as cred:
            self.credentials = pickle.load(cred)
        self.credentials.refresh(self.http)
        self.credentials.authorize(self.http)
        with open(CONFIG.CREDENTIALS, 'wb') as cred:
            pickle.dump(self.credentials, cred, -1)

TOKENIZE = re.compile(r'(\d+)|(\D+)').findall
def get_key(extractor=lambda x: x):
    u"""Extract sortable key from object for natural number sort.
    """
    def key(item):
        u"""Return sortable tuple for natural number sorting.
        """
        return tuple(int(num) if num else alpha.lower() for 
                     num, alpha in TOKENIZE(extractor(item)))
    return key

IGNORES = CONFIG.ignore_list()
def fnfilter(path_, is_dir=False):
    u"""Perform path filter on path_, return True if path_ should be retained.

    Keyword arguments:
    path_ -- Path to test against ignore patterns
    is_dir -- If True path_ is treated as a directory for pattern matching
    """
    #TODO: Add Doc to ignore pattern sematics
    for pattern in IGNORES:
        if pattern[-1] == u'/':
            if is_dir:
                pattern = pattern[:-1]
            else:
                continue
            if not fnmatch(path_, pattern):
                return False
    return True

class GDrive(object):
    #TODO: update with methods summaries
    u"""Controls communication with Google Drive.
    """
    class File (object):
        u"""Represents a remote file or folder on Google Drive.
        """
        def __init__(self, item):
            u"""Initialize storage of information regarding remote file on 
            Google Drive.

            Arguments:
            item -- Dictionary containing a File Resource

            See: 
               https://developers.google.com/drive/v2/reference/files#resource
            """
            self.item = item
            self.path = None
            self.id = item.get('id')
            self.parents = item.get('parents')
            self.title = item.get('title')
            self.labels = item.get('labels')
        def __unicode__(self):
            u"""Return a uicode representation of file path.
            """
            return self.path + os.sep + self.title

        def __str__(self):
            u"""Return a string representation of file path.
            """
            return unicode(self).encode('utf-8')

    def __init__ (self):
        u"""Initialize GDrive object and acquire authorization from stored
        credentials.
        """
        self.__auth = Auth()
        self.__auth.authorize()
        self.service = build('drive', 'v2', http=self.__auth.http)
        self.__files = None
        self.__ids = None
        self.__paths = None
   
    def __get_path(self, file_):
        u"""Return path of parent objects to file_.
        """
        path_ = []
        while file_:
            pars = []
            for par in file_.parents:
                parent = self.__ids.get(par['id'])
                if parent:
                    pars.append(parent)
            if len(pars) > 1:
                return None
            elif len(pars) == 1:
                path_.insert(0, pars[0].title)
            file_ = pars[0] if pars else None
        if not path_:
            return u'.'
        return u'.'+os.sep+unicode(os.sep).join(path_)
 
    def __find_paths(self):
        u"""Find all paths of files from self.__ids filtering paths with
        multiple accessible parents and trashed files.

        Set result to self.__paths and also return to caller
        """
        paths = {}
        for file_ in self.__ids.values():
            file_.path = self.__get_path(file_)
            if file_.path and not file_.labels.get('trashed'):
                paths[file_.path] = file_
        self.__paths = paths
        return paths
            
    def __sort_files(self):
        u"""Create self.__files as sorted list from paths in self.__paths.
        """
        files = self.__paths.values()
        files.sort(key=get_key(unicode))
        self.__files = files
        return files

    def update(self):
        u"""Update information about state of Google Drive.

        This must be called before any manipulation of files can occur.
        """
        ids = {}
        func = self.service.files().list
        page = None
        while True:
            params = {'fields': CONFIG.DLFIELDS}
            if page:
                params['pageToken'] = page
            items = func(**params).execute()
            for item in items['items']:
                file_ = self.File(item)
                ids[file_.id] = file_
            page = items.get('nextPageToken')
            if not page:
                break
        self.__ids = ids
        self.__find_paths()
        self.__sort_files()

    def list(self):
        u"""Return list of files and directorys in GoogleDrive.

        List will be sorted according to natural number sort.
        """
        return self.__files

class Local(object):
    u"""Controls local filesystem access
    """
    class File(object):
        u"""Represents file or directory on local file system.
        """
        def __init__(self, path_):
            u"""Initialize representation of local path_
            """
            self.path = unicode(path_)
            self.title = path.basename(self.path)
            self.parent = path.dirname(self.path)
            self.isdir = path.isdir(self.path)
            if self.isdir or not path.exists(self.path):
                self.length = 0
                self.mimetype = ('application/vnd.google-apps.folder' 
                    if self.isdir else None)
            else:
                self.length = path.getsize(self.path)
                self.mimetype = MIME.from_file(self.path)

        def getmtime(self):
            u"""Return datetime of last file modification.
            """
            # strip sub millisecond info from the timestamp
            # Google Drive does not prove greater resolution than 
            # millisecond
            time = int(path.getmtime(self.path)*1000)/1000.0
            return datetime.utcfromtimestamp(time)

        def getsmtime(self):
            u"""Get modification time string in RFC 3339 format
            """
            return self.getmtime().isoformat('T')+'Z'

        def __str__(self):
            u"""Return string representing file path.
            """
            return self.path.encode('utf-8')
        def __unicode__(self):
            u"""Return unicode representing file path.
            """
            return self.path

    def __init__(self):
        u"""Initialize local filesystem access
        """
        self.__files = None
        self.__paths = None

    def update(self):
        u"""Update representation of local file system.

        Note: Must be called before any manipulation of files can take place.
        """
        items = []
        paths = {}
        for root, dirs, files in os.walk(u'.'):
            if root != u'.':
                file_ = self.File(root)
                items.append(file_)
                paths[root] = file_
            i = 0
            while i < len(dirs):
                if fnfilter(root+u'/'+dirs[i], True):
                    i += 1
                else:
                    del dirs[i]
            key = get_key()
            dirs.sort(key=key)
            files.sort(key=key)
            for item in files:
                path_ = root+os.sep+item
                if fnfilter(path):
                    file_ = self.File(path_)
                    items.append(file_)
                    paths[path_] = file_
        self.__files = items
        self.__paths = paths

    def list(self):
        u"""Return list of local files sorted by natural number sort.
        """
        return self.__files

class Cache(object):
    u"""Controls cache/mapping of local vs remote files.

    NB: this class should never be created directly, it should always be 
    created by a call to static method Cache.load()
    """
    class File(object):
        u"""Represents a mapping of a local and remote file
        """
        def __init__(self, path_, id_, modified, length, md5_checksum):
            u"""Initialize representation of file mapping
            """
            self.path = path_
            self.id = id_
            self.modified = modified
            self.length = length
            self.md5_checksum = md5_checksum

    def __init__(self):
        u"""Iniitalize Cache Object
        """
        self.__ids = {}
        self.__paths = {}

    def add(self, path_, id_, modified, length, md5_checksum, save=False):
        u"""Add item to cache.

        Arguments:
        path_ -- unicode representation of local path
        id_ -- Id of file item on Google Drive
        modified -- datetime object representing last modified time of path
        length -- length of file in bytes. Must be 0 for directories
        md5_checksum - hexadecimal encode md5 checksum of file. must be 
                        None for directory
        save -- If True save updated cache immediately (default: False)
        """
        if path_ in self.__paths.keys():
            raise GoogleDriveSyncError('Path `%u` aready added!' % path)
        if id in self.__ids.keys():
            raise GoogleDriveSyncError('Id `%u` already added!' % id)
        file_ = self.File(path_, id_, modified, length, md5_checksum)
        self.__ids[id_] = file_
        self.__paths[path_] = file_
        if save:
            self.save()

    def remove_id(self, id_, save=False):
        u"""Remove and return item from cache by Google Drive id.

        Arguments:
        id_ -- Id of item on Google Drive
        save -- If True save updated cache immediately (default: False)
        """
        file_ = self.__ids.get(id_)
        if file_:
            del self.__ids[file_.id]
            del self.__paths[file_.path]
            if save:
                self.save()
        return file_

    def remove_path(self, path_, save=True):
        u"""Remove and return item from cache by local file path.

        Arguments:
        path_ -- unicode representaion of local path to item
        save -- If True save updated cache immediately (default: False)
        """
        file_ = self.__paths.get(path_)
        if file_:
            del self.__ids[file_.id]
            del self.__paths[file_.path]
            if save:
                self.save()
        return file_

    def save(self):
        u"""Save cache to disk for later runs.
        """
        with open(CONFIG.CACHE, 'wb') as cacheinfo:
            pickle.dump(self, cacheinfo, -1)

    @staticmethod
    def load ():
        u"""Load cache from disk, or create new cache if no saved cache.
        """
        try:
            with open(CONFIG.CACHE, 'rb') as cacheinfo:
                return pickle.load(cacheinfo)
        except:
            pass
        return Cache()

class Sync(object):
    u"""Manage the Sync between Google Drive and local filesystem.
    """
    def __init__(self, local, gdrive, cache):
        u"""Initialize Sync object.
        """
        self.local = local
        self.gdrive = gdrive
        self.cache = cache

    def sync(self):
        u"""Perform sync of Google Drive and local filesystem.
        """
        self.local.update()
        self.gdrive.update()


    def send_file(self, path_, convert=False):
        u"""Send new local file to Google Drive.
        """
        file_ = Local.File(path_)
        if file_.isdir:
            media = None
        else:
            media = MediaFileUpload(file_.path, mimetype=file_.mimetype, resumable=True)
        body = {
            'title': file_.title,
            'mimeType': file_.mimetype,
            'modifiedDate':file_.getsmtime()
        }
        fserv = self.gdrive.service.files()
        insert  = fserv.insert(body=body, media_body=media,
                            fields = CONFIG.ULFIELDS)
        if convert:
            insert.uri += u'&convert=true'
        return insert.execute()

if __name__ == '__main__':
    DRIVE = GDrive()
    LOCAL = Local()
    CACHE = Cache.load()
    SYNC = Sync(LOCAL, DRIVE, CACHE)
    SYNC.sync()
    pprint(SYNC.send_file('GoogleDriveSync-bak', True))
